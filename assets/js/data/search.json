[ { "title": "Autonomous Hybrid UAV", "url": "/posts/AutonomousDrone/", "categories": "Thesis", "tags": "C, Matlab, Drone", "date": "2022-06-24 12:00:00 +0200", "snippet": "Problem StatementUnmanned aerial vehicles (UAVs), such as quadcopters,are used in multiple applications varying from photography,package delivery, geographic mapping, crop monitoring, safetyinspections, surveillance, reconnaissance, and many other applications. With an increase in UAV applications, the mission profile of the UAV can vary based on the application itself.More tasks will require long endurance and an extended range.Applications for endurance and range are disaster managementand package delivery respectively.Hybrid UAVs combine the advantages of aircraft and quadcopters by being able to take-off and land vertically and being efficient in forward flight. However, due to the nonlinear behavior of the aerodynamic surfaces, a control system has to be designed that can handle the nonlinear behavior of the UAV.SetupThe Hybrid UAV I used during my Thesis is the Quadshot. It is equipped with a Lisa/MX autopilot. To program this autopilot, I used the open-source software Paparazzi. Paparazzi is a project that encompasses both the autopilot systems as well as the ground station and is mainly written in C. This gave me a better understanding of C, as my module also had to be developed in C.Control SystemThe basics of my control system are summed up by looking at the sum of all the forces acting on the drone.\\[\\textbf{a} = \\textbf{g} + \\frac{1}{m}\\textbf{L}_{wing}(\\eta,V) + \\textbf{D}_{wing}(\\eta,V) + \\textbf{D}_{side}(\\eta,V) + \\textbf{T}(\\eta,T)\\]Here \\(\\textbf{L}\\) and \\(\\textbf{D}\\) are the Lift and Drag forces respectively. They are dependent on the orientation \\(\\eta\\) and the freestream velocity \\(V\\). The last term \\(\\textbf{T}\\) represents the Thrust vector, dependent on the orientation \\(\\eta\\) and the thrust magnitude \\(T\\). Taking the Taylor Series expansion of this equation results:\\[\\textbf{a} - \\textbf{a}_{\\textbf{0}} = G (\\textbf{u} - \\textbf{u}_{\\textbf{0}})\\]Where:\\[\\textbf{u} = \\begin{bmatrix}\\eta \\\\ T\\end{bmatrix} = \\begin{bmatrix}\\phi \\\\\\theta \\\\\\psi \\\\T\\end{bmatrix}\\]And \\(G\\) is the partial derivative matrix that encompasses the influences of the forces acting on the body for a given change in orientation or thrust. This matrix is also called the control effectivenes. The vectorized notation of the equation is displayed below.\\[\\begin{bmatrix}\\Delta a_{X_B} \\\\\\Delta a_{Y_B} \\\\\\Delta a_{Z_B}\\end{bmatrix}= f\\begin{bmatrix}\\frac{\\partial a_{X_B}}{\\partial \\phi} &amp;amp; \\frac{\\partial a_{X_B}}{\\partial \\theta} &amp;amp; \\frac{\\partial a_{X_B}}{\\partial \\psi} &amp;amp; \\frac{\\partial a_{X_B}}{\\partial T} \\\\\\frac{\\partial a_{Y_B}}{\\partial \\phi} &amp;amp; \\frac{\\partial a_{Y_B}}{\\partial \\theta} &amp;amp; \\frac{\\partial a_{Y_B}}{\\partial \\psi} &amp;amp; \\frac{\\partial a_{Y_B}}{\\partial T} \\\\\\frac{\\partial a_{Z_B}}{\\partial \\phi} &amp;amp; \\frac{\\partial a_{Z_B}}{\\partial \\theta} &amp;amp; \\frac{\\partial a_{Z_B}}{\\partial \\psi} &amp;amp; \\frac{\\partial a_{Z_B}}{\\partial T} \\end{bmatrix}\\begin{bmatrix}\\Delta \\phi \\\\\\Delta\\theta \\\\\\Delta \\psi \\\\\\Delta T\\end{bmatrix}\\]My contribution is mainly to the esitmation of the control effectiveness matrix \\(G\\) to track the desired acceleration. The acceleration is achieved by incrementing the input vector \\(\\textbf{u}\\), similar to gradient decent algorithms.DemonstrationsHere are some videos of my implementation. The first video demonstrates a circular trajectory inside, while the second video is performed outside." }, { "title": "Data Encryption Tool", "url": "/posts/Encryption/", "categories": "Encryption", "tags": "Encryption, Python", "date": "2022-06-17 12:00:00 +0200", "snippet": "Problem StatementRecently, I required to use a USB flash drive that contained sensitive data. Therefor, it was beneficial to ensure that the stick was encrypted so that no one could read it in case it was lost.Searching for suitable tools for this task, I found BitLocker. However this tool works only on windows and third-party software is required on other operating systems to acces the encrypted files. Other crossplatform tools also exist, but these require you to install their software on every computer.What I wanted was a tool for data encryption that is cross platform and requires no installation. Since I didn’t find a suitable product, I decided to create my own.ApproachI chose to develop this in Python as I find it easy to prototype and due to the large collection of libraries available. Cryptography is a complex topic, so using cryptographic algorithms provided by the crytography library saves a lot of time.The program uses this library to generate a key by hashing the password with a randomly generated salt. This key will be saved on your computer locally for recovery in case you forget your password.The salt is saved on the USB stick with the encrypted files and the executables to encrypt and decrypt the folder.Here is a snip of the encryption.py file before it was compiled. The EncryptLib is a collection of functions I use for both encryption and decryption as they share a lot of functionality.import EncryptoLib as ELdef main(): [succes, salt] = EL.get_salt() if not succes: #No salt found for encryption return password = input(&quot;Enter password: &quot;) [succes, key] = EL.get_key(salt,password) if not succes: #Incorrect password provided return files = EL.get_decrypted_files() EL.encrypt_files(files,key)if __name__ == &quot;__main__&quot;: main()ResultThe resultion folders on the USB look like this:In the tools folder are the executables required for encryption, decryption, key generation and saving the key to the computer." }, { "title": "Interactive Shaders", "url": "/posts/GodotShaders/", "categories": "Interactive Tools", "tags": "Godot, Shaders, GLSL", "date": "2022-04-02 12:00:00 +0200", "snippet": "PortalWanting to experiment with shaders I created this portal shader. This shader can be applied to the object within a scene. If the players activates the portal, new objects apear on the other side of the portal.This is basically a transparency shader, where the mask of the shader is either expressed in global coordinates or in screen coordinates. The thing I wanted to obtain from this is the ability to ‘go to a different dimension’ while still keeping some of the spatial aspects for orientation purposes.The objects in the room have there own collision layer based on their ‘dimension’.DamageGodot does not have decals, a crucial way to project images to meshes. Game engines such as Unity and Unreal provide this functionality. To get similar functionality, I created a shader that I could use to display damage on meshes.I started with creating a viewport that would render the damage texture of the mesh in question. If a player shot the mesh with a raycast, an image will be drawn in the damage texture at UV coordinates of the raycast hit.Since the damage texture can be any format, I chose to use the RGB8 format. This means that I have three channels containing 8-bit damage info. I used the green channel to indicate the integrity of the mesh. Low integrity will cause the shader to displace the vertices and create a noisy normal map in that area, mimicking broken concrete. The red channel was used to indicate the amount of soot deposited on the mesh. Finally, blue indicates wetness and will cause the shader to adjust the roughness.In the video the shader is shown for the folowing damage paterns. The left one represents projectile type damage, while the right image represent a more impactfull/explosive type of damage.The last part of this video show a level of detail (LOD) system I created to reduce the number of faces in an object far away. For illustration purposes the number of faces in this video are reduced." }, { "title": "Trajectory Tool", "url": "/posts/GodotTrajectoryTool/", "categories": "Thesis", "tags": "Godot, GDScript", "date": "2022-03-21 11:00:00 +0100", "snippet": "Problem StatementDuring my thesis I had to design trajectories for my drone. These trajectories were difficult to design manually as they had to satisfy a few conditions: The trajectory should stay within position limits The trajectory should stay within velocity limits The trajectory should stay within acceleration limits The acceleration should be continuousThese constraint are caused by the physical limitations of the UAV. The position limit is an exception as this is defined by the fly region. Trivial solutions to the constraints are geometrical functions such as circles, however, for more flexible flight plans an alternate solution exists: splines.SolutionI decided to make a small tool to help me create trajectories for my thesis. This tool was only developed for myself, so I decided to spend my time on the functionality of the tool and not on the GUI. Window buttons were kept to a minimum as I personally work faster with keyboard shortcuts.For this, I used the Godot game engine with the scripting language GDScript (the scripting language of Godot).Creating Interactible FiguresI started of by creating an object for displaying figures. Figures are not included in godot, so I created a rectangle on which a viewort can be displayed. This viewport will contain the curves of that particular figure. The figure was also given axes with text labels. These are updated as the users scrolls or pans in the figure.Creating CurvesFor the curve I decided that each segment could be either a line, spline or a sinusoidal segment. The spline segment has an additional parameter that dictates how many handles are used per segment. One of the most common splines is the cubuc Bezier, which has two handles. However, the continuous acceleration constraint might require higher order bezier curves in the trajectory.Besides these options, draging the points or handles of the position versus time figure will update the splines in the velocity and acceleration figures.A brief demo is provided here." }, { "title": "Game Server Architecture", "url": "/posts/GodotServers/", "categories": "Interactive Tools", "tags": "Godot, GDScript, Encryption", "date": "2022-02-08 11:00:00 +0100", "snippet": "Being able to interact with other people online opens up a lot of new possibilities. But creating things such as multiplayer games introduces complexities.What I wanted to learn: Client-server connection Account creation Lag compensationThese were some of the things I worked on while exploring the topic of servers. Due to the experimental nature, I did not feel confident enough that my servers were secure, which led me to deployed the servers on a local network.Although I learned a lot from this, there is still more to learn: Load balancing Advanced lag compensation methods" }, { "title": "Visualizing Flight Data", "url": "/posts/GodotVisualizer/", "categories": "Thesis", "tags": "Godot, GDScript", "date": "2022-01-11 11:00:00 +0100", "snippet": "During my thesis I used paparazzi and matlab for flying my drone and analysing the data respectively. However, sometimes the reading the orientation of the drone can become tiresome, especially when represented in quaternion format.Therefor I decided to read out the flight data in Godot with its scripting language GDScript and visualise the orientaion of the drone next to the other relevant data. With the data I rotated a previously modeled drone in a seperate 3D viewport. Besides that I created my own figure plotter in godot and created a quick interface to scroll through the timeline.This was not a tool to actively analyse all the data, but it was usefull to check if the data was correct. I further improved my own figure object with text labels in the trajectory tool." }, { "title": "3D Web Graphics", "url": "/posts/THREEWebGraphics/", "categories": "Interactive Tools", "tags": "Three.js, Javascript", "date": "2021-11-19 11:00:00 +0100", "snippet": "I also experimented with Three.js, a 3D JavaScript library. The plan is to encorporate this in my modeled drone post. Here is an example of a simple scene with a torus and a light. Rotating is possible with the left mouse button. Note: The content of the page is not responsive and may appear squashed on smartphones and tables. " }, { "title": "GameJam", "url": "/posts/GodotGameJam/", "categories": "Interactive Tools", "tags": "Godot", "date": "2021-11-18 11:00:00 +0100", "snippet": "In Progress" }, { "title": "Drone Model", "url": "/posts/BlenderDroneModel/", "categories": "Thesis", "tags": "Modeling, Blender", "date": "2021-09-05 12:00:00 +0200", "snippet": " As a hobby I create models in Blender. Here is an example of a model I created for my thesis. This model was created so I can generate sketches for my paper, but it is also used in the flight visualizer." }, { "title": "VR Locomotion", "url": "/posts/GodotVRLocomotion/", "categories": "Interactive Tools", "tags": "Godot, VR, WebXR", "date": "2021-04-24 12:00:00 +0200", "snippet": "Having used VR for playing games, I was looking forward to experiment with this technology myself. Locomotion is a topic that has a wide range of solutions in the VR space. Some methods allow walking through the virtual world with a joystick, while others rely a teleportation mechanisme. The experience can also be build around traversing the environment by crawling with your hands or simply sit back and relax as you are driven around the virtual space with a virual trolley.I personally like the creative methods to traverse the virtual world, but I am not fond of the teleportation mechanism. I wanted to create a continous means of locomotion without breaking the immersion. The idea I wanted to try is to be able to ‘walk’ throught the world by walking in place.The concept is not that different from the walking platforms. However, the user base of those platforms is smaller than the user base of VR. Besides that, these platforms often come with a high price and take up space.My idea was that the velocity of the player could be based on the movement of the head. As the player walks in place, the VR headset will oscillate in height. This oscillation can be analysed and an velocity estimate can be determined. The oscillations of the height were analysed by using a fast fourier transform (FFT) to see the signal in the frequency domain. If the energy around the desired frequencies was high enough, it is assumed that the player is walking.Now that a velocity magnitude is obtained, the direction of that velocity vector needs to be determined. There are several options: walk in the direction of the VR headsets forward vector, walk in the direction of the VR controllers or walk in the direction you physically moved. I personally do not prefer the head orientation based velocity as a sudden surprise can change the velocity direction instantly even at top speed. Alternatively, I spend the most time on the latter option, where the players position influences the direction. By walking a bit forward the direction is set to forward etcetera.I used the webXR tools in Godot to create this. WebXR made my workflow easy as I didn’t need to install software on the oculus quest 2, but could just load the website I just deployed. In the video the graphs helped me see behind the screen,encoutered issues that still need to be fixed: head rotation can also contribute to false velocity estimate. oscillation detection delays should be decreased to minimize chance of nausea correlation between oscillation and speed might vary per person. Warning: During this video I was moving my head a lot. Watching may cause nausea. " }, { "title": "Unreal Course", "url": "/posts/UnrealBlueprints/", "categories": "Interactive Tools", "tags": "Unreal, Blueprints", "date": "2020-04-13 12:00:00 +0200", "snippet": "In Progress" }, { "title": "Car Simulation", "url": "/posts/UnityCarSimulation/", "categories": "Interactive Tools", "tags": "Unity, C#", "date": "2019-07-14 12:00:00 +0200", "snippet": "In Progress" }, { "title": "Drone Motor Test", "url": "/posts/ArduinoDrone/", "categories": "DIY", "tags": "Drone, Arduino, Raspberry Pi", "date": "2017-04-14 12:00:00 +0200", "snippet": "Working on a first version of my personal drone project. I had the powertrain completed and wanted to test this. I didn’t have the desired autopilot hardware, but wanted to test the motors anyway. I did have an Arduino Uno and a Raspberry Pi 3B at that time. Both of these contain pulse-width modulation (PWM) pins, required for the electronic speed controller (ESC) that controls the motor.On the Arduino I wrote a sample script to adjust the PWM signals to the ESCs. The video is the result of this program.On the Raspberry Pi I did the same thing, however, the Pi didn’t have the required amount of PWM pins. A workaround was to generate a software PWM signal (not with dedicated PWM generator hardware). This worked, but as the Raspberry Pi runs an Operating System, the signal stuttered from time to time. This made me switch to the Arduino until I got the desired autopilot." } ]
